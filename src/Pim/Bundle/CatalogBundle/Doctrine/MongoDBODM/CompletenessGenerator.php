<?php

namespace Pim\Bundle\CatalogBundle\Doctrine\MongoDBODM;

use Pim\Bundle\CatalogBundle\Doctrine\CompletenessGeneratorInterface;
use Pim\Bundle\CatalogBundle\Entity\Channel;
use Pim\Bundle\CatalogBundle\Entity\Locale;
use Pim\Bundle\CatalogBundle\Entity\Family;
use Pim\Bundle\CatalogBundle\Entity\Repository\CategoryRepository;
use Pim\Bundle\CatalogBundle\Model\ProductInterface;
use Pim\Bundle\CatalogBundle\Model\Completeness;
use Pim\Bundle\CatalogBundle\Manager\ChannelManager;
use Pim\Bundle\CatalogBundle\Factory\CompletenessFactory;
use Pim\Bundle\CatalogBundle\Validator\Constraints\ProductValueComplete;

use Doctrine\Common\Collections\ArrayCollection;
use Symfony\Component\Validator\ValidatorInterface;
use Doctrine\ODM\MongoDB\DocumentManager;
use Doctrine\MongoDB\Query\Builder;
use Doctrine\MongoDB\Query\Expr;

/**
 * Generate the completeness when Product are in MongoDBODM
 * storage. Please note that the generation for several products
 * is done on the MongoDB via a JS generated by the application via HTTP.
 *
 * This generator is only able to generate completeness for one product
 *
 * @author    Benoit Jacquemont <benoit@akeneo.com>
 * @copyright 2013 Akeneo SAS (http://www.akeneo.com)
 * @license   http://opensource.org/licenses/osl-3.0.php  Open Software License (OSL 3.0)
 */
class CompletenessGenerator implements CompletenessGeneratorInterface
{
    /**
     * @var DocumentManager;
     */
    protected $documentManager;

    /**
     * @var CompletenessFactory
     */
    protected $completenessFactory;

    /**
     * @var ValidatorInterface
     */
    protected $validator;

    /**
     * @var string
     */
    protected $productClass;

    /**
     * @var ChannelManager
     */
    protected $channelManager;

    /**
     * @var CategoryRepository
     */
    protected $categoryRepository;

    /**
     * Constructor
     *
     * @param DocumentManager     $documentManager
     * @param CompletenessFactory $completenessFactory
     * @param ValidatorInterface  $validator
     * @param string              $productClass
     * @param ChannelManager      $channelManager
     * @param CategoryRepository  $categoryRepository
     */
    public function __construct(
        DocumentManager $documentManager,
        CompletenessFactory $completenessFactory,
        ValidatorInterface $validator,
        $productClass,
        ChannelManager $channelManager,
        CategoryRepository $categoryRepository
    ) {
        $this->documentManager     = $documentManager;
        $this->completenessFactory = $completenessFactory;
        $this->validator           = $validator;
        $this->productClass        = $productClass;
        $this->channelManager      = $channelManager;
        $this->categoryRepository  = $categoryRepository;
    }

    /**
     * {@inheritdoc}
     */
    public function generateMissingForProduct(ProductInterface $product, $flush = true)
    {
        if (null === $product->getFamily()) {
            return;
        }

        $completenesses = $this->buildProductCompletenesses($product);

        $product->setCompletenesses(new ArrayCollection($completenesses));

        if ($flush) {
            $this->documentManager->flush($product);
        }
    }

    /**
     * {@inheritdoc}
     */
    public function generateMissingForChannel(Channel $channel)
    {
    }

    /**
     * Build the completeness for the product
     *
     * @param ProductInterface $product
     *
     * @return array
     */
    public function buildProductCompletenesses(ProductInterface $product)
    {
        $completenesses = array();

        $stats = $this->collectStats($product);

        foreach ($stats as $channelStats) {
            $channel = $channelStats['object'];
            $channelData = $channelStats['data'];
            $channelRequiredCount = $channelData['required_count'];

            foreach ($channelData['locales'] as $localeStats) {
                $completeness = $this->completenessFactory->build(
                    $channel,
                    $localeStats['object'],
                    $localeStats['missing_count'],
                    $channelRequiredCount
                );

                $completenesses[] = $completeness;
            }
        }

        return $completenesses;
    }

    /**
     * Generate statistics on the product completeness
     *
     * @param ProductInterface $product
     *
     * @return array $stats
     */
    protected function collectStats(ProductInterface $product)
    {
        $stats = array();
        $family = $product->getFamily();

        if (null === $family) {
            return $stats;
        }

        $channels = $this->channelManager->getFullChannels();

        foreach ($channels as $channel) {
            $channelCode = $channel->getCode();

            $stats[$channelCode]['object'] = $channel;
            $stats[$channelCode]['data'] = $this->collectChannelStats($channel, $product);
        }

        return $stats;
    }

    /**
     * Generate stats on product completeness for a channel
     *
     * @param Channel          $channel
     * @param ProductInterface $product
     *
     * @return array $stats
     */
    protected function collectChannelStats(Channel $channel, ProductInterface $product)
    {
        $stats = array();
        $locales = $channel->getLocales();
        $completeConstraint = new ProductValueComplete(array('channel' => $channel));
        $stats['required_count'] = 0;
        $stats['locales'] = array();
        $requirements = $product->getFamily()->getAttributeRequirements();

        foreach ($requirements as $req) {
            if (!$req->isRequired() || $req->getChannel() != $channel) {
                continue;
            }
            $stats['required_count']++;

            foreach ($locales as $locale) {
                $localeCode = $locale->getCode();

                if (!isset($stats['locales'][$localeCode])) {
                    $stats['locales'][$localeCode] = array();
                    $stats['locales'][$localeCode]['object'] = $locale;
                    $stats['locales'][$localeCode]['missing_count'] = 0;
                }

                $attribute = $req->getAttribute();
                $value = $product->getValue($attribute->getCode(), $localeCode, $channel->getCode());

                if (!$value || $this->validator->validateValue($value, $completeConstraint)->count() > 0) {
                    $stats['locales'][$localeCode]['missing_count'] ++;
                }
            }
        }

        return $stats;
    }

    /**
     * {@inheritdoc}
     */
    public function generateMissing()
    {
        $this->generate();
    }

    /**
     * Generate missing completenesses for a channel if provided or a product
     * if provided.
     *
     * @param Product $product
     * @param Channel $channel
     */
    protected function generate(ProductInterface $product = null, Channel $channel = null)
    {
        $productsQb = $this->documentManager->createQueryBuilder($this->productClass);

        $this->applyFindMissingQuery($productsQb, $product, $channel);

        $products = $productsQb->getQuery()->execute();

        foreach ($products as $product) {
            // Flushing at each iteration has a big impact on perf
            $this->generateMissingForProduct($product, false);
        }

        $this->documentManager->flush();
    }

    /**
     * Apply the query part to search for product where the completenesses
     * are missing. Apply only to the channel or product if provided.
     *
     * @param Builder $productsQb
     * @param Product $product
     * @param Channel $channel
     */
    protected function applyFindMissingQuery(
        Builder $productsQb,
        ProductInterface $product = null,
        Channel $channel = null
    ) {
        if (null !== $product) {
            $productsQb->field('_id')->equals($product->getId());
        } else {
            $combinations = $this->getCombinations($channel);

            if (!empty($combinations)) {
                $orItems = new Expr();
                foreach ($combinations as $combination) {
                    $orItems->field('normalizedData.completenesses.'.$combination)->exists(false);
                }
                $productsQb->addOr($orItems);
            }
        }

        $productsQb->field('family')->notEqual(null);
    }

    /**
     * Generate a list of potential completeness value from existing channel
     * or from the provided channel
     *
     * @param Channel $channel
     *
     * @return array
     */
    protected function getCombinations(Channel $channel = null)
    {
        $channels = array();
        $combinations = array();

        if (null !== $channel) {
            $channels = [$channel];
        } else {
            $channels = $this->channelManager->getFullChannels();
        }

        foreach ($channels as $channel) {
            $locales = $channel->getLocales();
            foreach ($locales as $locale) {
                $combinations[] = $channel->getCode().'-'.$locale->getCode();
            }
        }

        return $combinations;
    }

    /**
     * {@inheritdoc}
     */
    public function schedule(ProductInterface $product)
    {
        $product->setCompletenesses(new ArrayCollection());

        $this->documentManager->flush($product);
    }

    /**
     * {@inheritdoc}
     */
    public function scheduleForFamily(Family $family)
    {
        $productQb = $this->documentManager->createQueryBuilder($this->productClass);

        $productQb
            ->hydrate(false)
            ->findAndUpdate()
            ->field('family')->equals($family->getId())
            ->field('completenesses')->unsetField()
            ->field('normalizedData.completenesses')->unsetField()
            ->getQuery()
            ->execute();
    }

    /**
     * {@inheritdoc}
     */
    public function getProductsCountPerChannels()
    {
        $channels = $this->channelManager->getFullChannels();
        $productRepo = $this->documentManager->getRepository($this->productClass);

        $productsCount = array();
        foreach ($channels as $channel) {
            $category = $channel->getCategory();
            $categoryQb = $this->categoryRepository->getAllChildrenQueryBuilder($category, true); 
            $categoryIds = $this->categoryRepository->getCategoryIds($category, $categoryQb);

            $qb = $productRepo->createQueryBuilder()
                ->hydrate(false)
                ->field('categories')->in($categoryIds)
                ->field('enabled')->equals(true)
                ->select('_id');

            $productsCount[] = [
                'label' => $channel->getLabel(),
                'total' => $qb->getQuery()->execute()->count()
            ];
        }

        return $productsCount;
    }

    /**
     * {@inheritdoc}
     */
    public function getCompleteProductsCountPerChannels()
    {
        $channels = $this->channelManager->getFullChannels();
        $productRepo = $this->documentManager->getRepository($this->productClass);

        $productsCount = array();
        foreach ($channels as $channel) {
            $category = $channel->getCategory();
            $categoryQb = $this->categoryRepository->getAllChildrenQueryBuilder($category, true); 
            $categoryIds = $this->categoryRepository->getCategoryIds($category, $categoryQb);

            $qb = $productRepo->createQueryBuilder()
                ->hydrate(false)
                ->field('categories')->in($categoryIds)
                ->field('enabled')->equals(true)
                ->select('_id');

            $channelCount = $qb->getQuery()->execute()->count();
            $data = array();

            foreach ($channel->getLocales() as $locale) {
                $data['locale'] = $locale->getCode();
                $data['label'] = $channel->getLabel();
                $data['total'] = $channelCount;
                $data['complete'] = $channelCount;
            }

            $productsCount[] = $data;
        }

        return $productsCount;
    }

    /**
     * Return categories ids provided by the categoryQb or by the provided category
     *
     * @param CategoryInterface $category
     * @param OrmQueryBuilder   $categoryQb
     *
     * @return array $categoryIds
     */
    protected function getCategoryIds(CategoryInterface $category, OrmQueryBuilder $categoryQb = null)
    {
        $categoryIds = array();

        if (null !== $categoryQb) {
            $categoryAlias = $categoryQb->getRootAlias();
            $categories = $categoryQb->select('PARTIAL '.$categoryAlias.'.{id}')->getQuery()->getArrayResult();
        } else {
            $categories = array(array('id' => $category->getId()));
        }

        foreach ($categories as $category) {
            $categoryIds[] = $category['id'];
        }

        return $categoryIds;
    }
}
